package com.zhuo.im.service.utils;


import cn.hutool.core.date.SystemClock;
import lombok.extern.slf4j.Slf4j;

/**
 * @description:
 **/
@Slf4j
public class SnowflakeIdWorker {

    /**
     * Initial offset timestamp
     */
    private static final long OFFSET = 1546300800L;

    /**
     * Machine id (0~15, reserve 16~31 as backup machine)
     */
    private static long WORKER_ID;

    /**
     * The number of digits occupied by the machine ID (5bit, the maximum number of machines supported is 2^5 = 32)
     */
    private static final long WORKER_ID_BITS = 5L;

    /**
     * The number of bits occupied by the auto-increment sequence (16bit, supports a maximum generation of 2^16 = 65536 per second)
     */
    private static final long SEQUENCE_ID_BITS = 16L;

    /**
     * Machine ID offset digits
     */
    private static final long WORKER_SHIFT_BITS = SEQUENCE_ID_BITS;

    /**
     * Auto-increment sequence offset number
     */
    private static final long OFFSET_SHIFT_BITS = SEQUENCE_ID_BITS + WORKER_ID_BITS;

    /**
     * Maximum machine ID (2^5 / 2 - 1 = 15)
     */
    private static final long WORKER_ID_MAX = ((1 << WORKER_ID_BITS) - 1) >> 1;

    /**
     * The starting position of the backup machine ID (2^5 / 2 = 16)
     */
    private static final long BACK_WORKER_ID_BEGIN = (1 << WORKER_ID_BITS) >> 1;

    /**
     * Maximum value of self-increasing sequence (2^16 - 1 = 65535)
     */
    private static final long SEQUENCE_MAX = (1 << SEQUENCE_ID_BITS) - 1;

    /**
     * Maximum tolerated callback time (seconds) when time callback occurs
     */
    private static final long BACK_TIME_MAX = 1L;

    /**
     * Timestamp of last generated ID (seconds)
     */
    private static long lastTimestamp = 0L;

    /**
     * Sequence within the current second (2^16)
     */
    private static long sequence = 0L;

    /**
     * The timestamp of the last ID generated by the backup machine (seconds)
     */
    private static long lastTimestampBak = 0L;

    /**
     * Sequence within the current second of the backup machine (2^16)
     */
    private static long sequenceBak = 0L;

    //==============================Constructors====================

    /**
     * Constructor
     * @param workerId workerID (0~31)
     */
    public SnowflakeIdWorker(long workerId) {

        if (workerId < 0 || workerId > WORKER_ID_MAX) {
            throw new IllegalArgumentException(String.format("cmallshop.workerId range: 0 ~ %d Current: %d", WORKER_ID_MAX, workerId));
        }
        WORKER_ID = workerId;
    }

    // ==============================Methods=================================
    public static long nextId() {
        return nextId(SystemClock.now() / 1000);
    }

    /**
     * Main machine auto-increment sequence
     *
     * @param timestamp Current Unix timestamp
     * @return long
     */
    private static synchronized long nextId(long timestamp) {

        // Check whether the clock is set back
        if (timestamp < lastTimestamp) {
            // Clock rollback occurs
            log.warn("Clock is set back, enable backup machine ID: now: [{}] last: [{}]", timestamp, lastTimestamp);
            return nextIdBackup(timestamp);
        }

        // Start next second
        if (timestamp != lastTimestamp) {
            lastTimestamp = timestamp;
            sequence = 0L;
        }
        if (0L == (++sequence & SEQUENCE_MAX)) {
            // Sequence exhausted
            // log.warn("[{}] sequence is exhausted, enable backup machine ID sequence", timestamp);
            sequence--;
            return nextIdBackup(timestamp);
        }

        return ((timestamp - OFFSET) << OFFSET_SHIFT_BITS) | (WORKER_ID << WORKER_SHIFT_BITS) | sequence;
    }

    /**
     * Block until next millisecond until new timestamp is obtained
     *
     * @param lastTimestamp The last time the ID was generated
     * @return Current timestamp
     */
    protected long tilNextMillis(long lastTimestamp) {

        long timestamp = timeGen();
        while (timestamp <= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    /**
     * Backup machine auto-increment sequence
     * @param timestamp Current Unix timestamp
     * @return long
     */
    private static long nextIdBackup(long timestamp) {

        if (timestamp < lastTimestampBak) {
            if (lastTimestampBak - SystemClock.now() / 1000 <= BACK_TIME_MAX) {
                timestamp = lastTimestampBak;
            } else {
                throw new RuntimeException(String.format("Clock is set back. now: [%d] last: [%d]", timestamp, lastTimestampBak));
            }
        }

        if (timestamp != lastTimestampBak) {
            lastTimestampBak = timestamp;
            sequenceBak = 0L;
        }

        if (0L == (++sequenceBak & SEQUENCE_MAX)) {
            // Sequence exhausted
//            logger.warn("The [{}] sequence is exhausted. The backup machine ID borrows the next second sequence", timestamp);
            return nextIdBackup(timestamp + 1);
        }

        return ((timestamp - OFFSET) << OFFSET_SHIFT_BITS) | ((WORKER_ID ^ BACK_WORKER_ID_BEGIN) << WORKER_SHIFT_BITS) | sequenceBak;
    }


    /**
     * Returns the current time in milliseconds
     *
     * @return Current time (milliseconds)
     */
    protected long timeGen() {
        return System.currentTimeMillis();
    }

}
